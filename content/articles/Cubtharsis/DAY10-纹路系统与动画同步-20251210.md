# DAY10 - 2025.12.10 (周三)

## 完成内容

### 纹路系统（Pattern System）

创建 `Scripts/Pattern/` 文件夹，实现魔方纹路谜题完整框架：

**PatternConnector.cs** - 挂在 Sticker 上
- 4 个 bool 定义连接点方向：`top/right/bottom/left`
- `isActivationPoint` 标记激活点（起点）
- LineRenderer 实时绘制纹路线
- 颜色状态：绿色=连通/激活，黄色=未连通
- `[ExecuteInEditMode]` 编辑器实时预览

**PatternValidator.cs** - 挂在魔方根节点
- 自动收集所有 PatternConnector
- BFS 从激活点扩散检测连通性
- **基于世界坐标的实时相邻检测**（支持转动后更新）
- 事件：`OnAllConnected`、`OnConnectionChanged`

纹路类型示例：
- 直线（竖）：top + bottom
- 直线（横）：left + right  
- L型：top + right
- T型：top + right + bottom
- 十字：top + right + bottom + left

---

### 转动后连通检测修复

**问题**：转动魔方后，纹路连通状态不更新

**原因分析**：
- 原方案用 Cubie 名字解析位置（如 `Cubie_0_1_-1`）
- 转动后 Cubie 实际位置变了，但名字没变
- 用固定的"对面方向"枚举匹配，不考虑旋转

**解决方案**：
- 改用 `TransformPoint` 获取边缘点的**实时世界坐标**
- 遍历所有 Connector 的所有激活方向，直接比较世界坐标距离
- 距离小于 `neighborDistance`（0.3f）即认为连通

```csharp
// 获取边缘点世界坐标（自动考虑旋转）
Vector3 edgeWorldPos = t.TransformPoint(localEdge);

// 比较两个边缘点的世界坐标距离
float dist = Vector3.Distance(edgeWorldPos, otherEdgePos);
if (dist < neighborDistance) { /* 连通！ */ }
```

---

### 摄像机与魔方动画同步优化

**问题1**：魔方浮空时摄像机跟不上
**问题2**：进入Puzzle视角时闪烁
**问题3**：退出Puzzle时应恢复之前的档位

**解决方案**：
- 摄像机全程使用统一的 SmoothDamp 平滑跟随
- 进入 Puzzle 前等待 0.5 秒让摄像机过渡到魔方位置
- 记住进入 Puzzle 前的档位，退出时恢复

**魔方动画优化**：
- 使用 EaseInOutExpo 缓动曲线（指数缓入缓出）
- 开始和结束几乎静止，中间快速移动
- `floatDuration` 控制动画时长

---

## 当前脚本结构

```
Scripts/
├── Pattern/                    # 新增
│   ├── PatternConnector.cs     # 纹路连接器（挂 Sticker）
│   ├── PatternValidator.cs     # 连通性验证器（世界坐标检测）
│   └── README.md
├── Player/
│   └── IsometricCamera.cs      # 修改：Puzzle模式直接跟随
├── Puzzle/
│   └── PuzzleCube.cs           # 修改：SmoothDamp动画
└── ...
```

---

---

### 情绪能力与传导系统

重构 `Scripts/Emotion/` 文件夹，实现完整的情绪能力传导链：

**EmotionAbility.cs** - 玩家情绪能力
- Q 键触发"悲伤/下雨"效果
- DirectionalLight 颜色渐变（暖白 → 蓝色）
- 广播事件：`OnRainStart`、`OnRainEnd`

**RainReceiver.cs** - 雨水接收器
- 监听下雨事件，下雨时激活
- 材质变蓝，作为传导链起点

**Conduit.cs** - 简单传导体
- 检测附近激活物体，链式传导
- 基于距离检测，不依赖 Collider

**ConduitPath.cs** - 路径传导器（新增）
- 子物体作为路径点，可自由拖动编辑
- LineRenderer 自动连接所有点
- **每个路径点都可接收/传递激活**
- 支持弯曲、转角等任意形状

**IActivatable.cs** - 统一接口
```csharp
public interface IActivatable {
    bool IsActivated { get; }
    void Activate();
    void Deactivate();
}
```

**传导流程**：
```
玩家按Q → 环境下雨 → RainReceiver激活 → ConduitPath传导 → PatternConnector激活 → 纹路连通
```

---

### PatternConnector 外部激活支持

修改 `PatternConnector.cs`，实现 IActivatable 接口：
- `canBeExternallyActivated` - 是否可被外部激活
- 检测附近的 Conduit / ConduitPath
- 被激活后作为纹路系统的起点

---

## 当前脚本结构

```
Scripts/
├── Emotion/                    # 重构
│   ├── IActivatable.cs         # 可激活接口
│   ├── EmotionAbility.cs       # 玩家情绪能力
│   ├── RainReceiver.cs         # 雨水接收器
│   ├── Conduit.cs              # 简单传导体
│   ├── ConduitPath.cs          # 路径传导器（新增）
│   └── README.md
├── Pattern/
│   ├── PatternConnector.cs     # 修改：支持外部激活
│   └── PatternValidator.cs
└── ...
```

---

## 下一步

- [ ] 跨面连通检测（U面边缘连到F面）
- [ ] 简单谜题原型整合测试
- [ ] 更多情绪能力（愤怒/恐惧/孤独）

---

---

### 传导循环依赖修复

**问题**：两条 ConduitPath 互相检测激活状态，形成循环依赖，导致断电后仍保持激活

**解决方案**：创建 `ConduitManager.cs` 统一管理传导状态
- 每帧先重置所有传导体为未激活
- 从激活的 RainReceiver 开始 BFS 扩散
- 只有能追溯到电源的传导体才会被激活
- 避免循环依赖问题

```csharp
// ConduitManager 核心逻辑
void UpdateAllConduits() {
    // 1. 重置所有传导体
    // 2. 从 RainReceiver 开始 BFS
    // 3. 扩散激活相邻的传导体
}
```

---

## 当前脚本结构

```
Scripts/
├── Emotion/
│   ├── IActivatable.cs         # 可激活接口
│   ├── EmotionAbility.cs       # 玩家情绪能力
│   ├── RainReceiver.cs         # 雨水接收器
│   ├── Conduit.cs              # 简单传导体
│   ├── ConduitPath.cs          # 路径传导器
│   ├── ConduitManager.cs       # 传导管理器（新增）
│   └── README.md
├── Pattern/
│   ├── PatternConnector.cs     # 纹路连接器
│   └── PatternValidator.cs     # 连通验证器
└── ...
```

---

## Memory

- [x] LineRenderer 尺寸问题 → Quad 本地坐标范围是 -0.5 到 0.5，不受 scale 影响
- [x] 摄像机跟不上魔方 → 统一使用 SmoothDamp，进入 Puzzle 前等待过渡
- [x] 进入 Puzzle 闪烁 → 分两步：先切换摄像机目标，等待过渡后再上升
- [x] 魔方动画太硬 → 使用 EaseInOutExpo 缓动曲线（指数缓入缓出）
- [x] 转动后连通不更新 → 改用 TransformPoint 获取世界坐标，直接比较边缘点距离
- [x] Conduit 检测不到 RainReceiver → 改用 FindObjectsOfType + 距离检测，不依赖 Collider
- [x] 传导器需要灵活路径 → 创建 ConduitPath，子物体作为路径点，每个点都可接收/传递
- [x] 传导循环依赖 → 创建 ConduitManager，从 RainReceiver 开始 BFS 扩散，避免互相激活
